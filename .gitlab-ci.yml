stages:
  - test
  - build
  - deploy
  - cleanup


variables:
  DOCKER_AUTH_CONFIG: ${CI_DOCKER_AUTH_CONFIG}
  CLICOLOR_FORCE: 1


pre:
  stage: .pre
  script:
    # download jq
    - |
      target_arch=$(arch);
      case ${target_arch} in
        "x86_64")  target_arch_alt=amd64   ;;
        "aarch64")  target_arch_alt=arm64  ;;
      esac;
    - |
      curl -s -S -L -X 'GET' --max-time 10 \
        "https://github.com/jqlang/jq/releases/download/jq-${JQ_VERSION}/jq-linux-${target_arch_alt}" \
        -o /usr/local/bin/jq
    - chmod +x /usr/local/bin/jq;
  rules:
    # if event = merge request creation && source = /^feature\/A[DV]-\d+$/ && target = main
    - if: $CI_PIPELINE_SOURCE == 'merge_request_event' &&
          $CI_MERGE_REQUEST_SOURCE_BRANCH_NAME =~ $FEATURE_BRANCH_REGEX &&
          $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == $MAIN_BRANCH
    # if event = push && target = main
    - if: $CI_PIPELINE_SOURCE == 'push' &&
          $CI_COMMIT_BRANCH == $MAIN_BRANCH
  tags:
    - avataa-platform-shell
  interruptible: true


lint:
  stage: test
  image: ${REGISTRY_URL}/${PROJECT_NAME}/${PYTHON_IMAGE}:${PYTHON_IMAGE_VERSION}
  script:
    - uv sync --only-group ${UV_GROUP_LINT}
    - source .venv/bin/activate
    - ruff check ${APP_DIR} || ruff check --statistics ${APP_DIR}
    - ruff format --diff ${APP_DIR} || ruff format --check ${APP_DIR}
    - if [ -d "${TESTS_DIR}" ]; then ruff check ${TESTS_DIR} || ruff check --statistics ${TESTS_DIR}; fi
    - if [ -d "${TESTS_DIR}" ]; then ruff format --diff ${TESTS_DIR} || ruff format --check ${TESTS_DIR}; fi
  rules:
    # if event = merge request creation && source = /^feature\/A[DV]-\d+$/ && target = main
    - if: $CI_PIPELINE_SOURCE == 'merge_request_event' &&
          $CI_MERGE_REQUEST_SOURCE_BRANCH_NAME =~ $FEATURE_BRANCH_REGEX &&
          $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == $MAIN_BRANCH
    # if event = push && target = main
    - if: $CI_PIPELINE_SOURCE == 'push' &&
          $CI_COMMIT_BRANCH == $MAIN_BRANCH
  tags:
    - avataa-platform-docker
  interruptible: true

unit_test:
  variables:
    # postgresql env vars
    TESTS_RUN_CONTAINER_POSTGRES_LOCAL: False
    TESTS_DB_TYPE: ${TESTS_DB_TYPE}
    TESTS_DB_USER: ${TESTS_POSTGRES_USER}
    TESTS_DB_PASS: ${TESTS_POSTGRES_PASSWORD}
    TESTS_DB_HOST: ${TESTS_DB_HOST}
    TESTS_DB_PORT: ${TESTS_DB_PORT}
    TESTS_DB_NAME: ${TESTS_POSTGRES_DB}
    # postgresql container as service
    POSTGRES_DB: ${TESTS_POSTGRES_DB}
    POSTGRES_USER: ${TESTS_POSTGRES_USER}
    POSTGRES_PASSWORD: ${TESTS_POSTGRES_PASSWORD}
  stage: test
  image: ${REGISTRY_URL}/${PROJECT_NAME}/${PYTHON_IMAGE}:${PYTHON_IMAGE_VERSION}
  services:
    - name: ${POSTGRES_IMAGE}:${POSTGRES_VERSION}
      alias: postgres
  script:
    - uv sync --no-dev --group ${UV_GROUP_TESTS}
    - source .venv/bin/activate
    - pytest
  rules:
    # if event = merge request creation && source = /^feature\/A[DV]-\d+$/ && target = main
    - if: $CI_PIPELINE_SOURCE == 'merge_request_event' &&
          $CI_MERGE_REQUEST_SOURCE_BRANCH_NAME =~ $FEATURE_BRANCH_REGEX &&
          $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == $MAIN_BRANCH
    # if event = push && target = main
    - if: $CI_PIPELINE_SOURCE == 'push' &&
          $CI_COMMIT_BRANCH == $MAIN_BRANCH
  tags:
    - avataa-platform-docker
  interruptible: true

migrations_test:
  stage: test
  variables:
    DB_TYPE: ${TESTS_DB_TYPE}
    DB_USER: ${TESTS_POSTGRES_USER}
    DB_PASS: ${TESTS_POSTGRES_PASSWORD}
    DB_HOST: ${TESTS_DB_HOST}
    DB_PORT: ${TESTS_DB_PORT}
    DB_NAME: ${TESTS_POSTGRES_DB}
    # postgresql container as service
    POSTGRES_DB: ${TESTS_POSTGRES_DB}
    POSTGRES_USER: ${TESTS_POSTGRES_USER}
    POSTGRES_PASSWORD: ${TESTS_POSTGRES_PASSWORD}
  image: ${REGISTRY_URL}/${PROJECT_NAME}/${PYTHON_IMAGE}:${PYTHON_IMAGE_VERSION}
  services:
    - name: ${POSTGRES_IMAGE}:${POSTGRES_VERSION}
      alias: postgres
  script:
    - uv sync --only-group ${UV_GROUP_MIGRATIONS}
    - source .venv/bin/activate
    - cd ${APP_DIR}
    - ${MIGRATIONS_COMMAND}
  rules:
    # if event = merge request creation && source = /^feature\/A[DV]-\d+$/ && target = main
    - if: $CI_PIPELINE_SOURCE == 'merge_request_event' &&
          $CI_MERGE_REQUEST_SOURCE_BRANCH_NAME =~ $FEATURE_BRANCH_REGEX &&
          $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == $MAIN_BRANCH
    # if event = push && target = main
    - if: $CI_PIPELINE_SOURCE == 'push' &&
          $CI_COMMIT_BRANCH == $MAIN_BRANCH
  tags:
    - avataa-platform-docker
  interruptible: true

package_vulns_test:
  stage: test
  variables:
    TRIVY_NO_PROGRESS: "true"
    TRIVY_DISABLE_VEX_NOTICE: "true"
    TRIVY_REPORT_FILENAME: ${TRIVY_REPORT_FILENAME}
  image: ${REGISTRY_URL}/${PROJECT_NAME}/${PYTHON_IMAGE}:${PYTHON_IMAGE_VERSION}
  script:
    - uv sync --all-groups
    - uv --color never pip freeze > ${REQUIREMENTS_FILENAME}
    - source .venv/bin/activate
    # WARN force true
    - pip-audit --aliases -r ${REQUIREMENTS_FILENAME} || true
    - trivy fs --pkg-types=library --format table --scanners vuln --exit-code 1 ${REQUIREMENTS_FILENAME}
      --output ${TRIVY_REPORT_FILENAME} || cat ${TRIVY_REPORT_FILENAME}
  rules:
    # if event = merge request creation && source = /^feature\/A[DV]-\d+$/ && target = main
    - if: $CI_PIPELINE_SOURCE == 'merge_request_event' &&
          $CI_MERGE_REQUEST_SOURCE_BRANCH_NAME =~ $FEATURE_BRANCH_REGEX &&
          $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == $MAIN_BRANCH
    # if event = push && target = main
    - if: $CI_PIPELINE_SOURCE == 'push' &&
          $CI_COMMIT_BRANCH == $MAIN_BRANCH
  tags:
    - avataa-platform-docker
  # allow_failure: true
  interruptible: true
  artifacts:
    when: always
    paths:
      - trivy_report.txt


analyse_code_main:
  stage: test
  image:
    name: ${REGISTRY_URL}/${PROJECT_NAME}/${SONAR_SCANNER_CLI_IMAGE}:${SONAR_SCANNER_CLI_VERSION}
    entrypoint: [""]
  script:
    - cd ${APP_DIR}
    - /usr/bin/entrypoint.sh sonar-scanner
        -Dsonar.host.url=${SONARQUBE_URL}
        -Dsonar.sources=.
        -Dsonar.python.version=${PYTHON_VERSION}
        -Dsonar.projectKey=${SONARQUBE_PROJECT_KEY}
        -Dsonar.projectName="${SONARQUBE_PROJECT_NAME}"
        -Dsonar.token=${SONARQUBE_PROJECT_TOKEN}
  rules:
    # if event = push && target = main
    - if: $CI_PIPELINE_SOURCE == 'push' &&
          $CI_COMMIT_BRANCH == $MAIN_BRANCH
  tags:
    - avataa-platform-docker
  # allow_failure: true
  interruptible: true


generate_version:
  stage: build
  variables:
    GIT_STRATEGY: clone
  image:
    name: ${REGISTRY_URL}/${PROJECT_NAME}/${GIT_IMAGE}:${GIT_VERSION}
    entrypoint: [""]
  before_script:
    - git config --global --add safe.directory $CI_PROJECT_DIR
    - git switch $MAIN_BRANCH
  script:
    # get current project version
    - current_version=$(uv version --short)
    # check current project version
    - echo "Current project version is ${current_version}"
    - git remote set-url origin https://gitlab-ci-token:${GITLAB_API_TOKEN}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git
    # NOTE implement latest_tag if needed
    # - git fetch --tags
    # - latest_tag=$(git describe --tags --abbrev=0 2>/dev/null)
    # # check latest tag
    # - |
    #   if [ -z "$latest_tag" ]; then
    #     echo "No tags found, add new one"
    #   else
    #     echo "Latest tag is ${latest_tag}"
    #   fi
    # # compare latest tag with current project tag
    # - |
    #   if [ "$latest_tag" = "$current_version" ]; then
    #     echo "Latest tag equals current project version"
    #   else
    #     echo "Sync latest tag with current project version, project version takes precedence"
    #     latest_tag=$current_version
    #   fi
    # increase project version by 1 (patch)
    - uv version --no-sync --bump patch
    - new_tag=$(uv version --short --color never)
    - echo "New version/tag is ${new_tag}"
    # put new version to file for next jobs
    - echo ${new_tag} > ${BUILDS_CI_PATH}/${CI_PROJECT_NAME}_new_version
    # commit version bump to "main" branch
    - git config user.email "${GIT_CI_USER_EMAIL}"
    - git config user.name "${GIT_CI_USER_NAME}"
    - rm ${TRIVY_REPORT_FILENAME}
    - git add -A
    - git commit -m "CI - bump version to ${new_tag} [skip ci]"
    # push new project version (in pyproject.toml) to repository
    # - git push
    # create tag
    - git tag "${new_tag}"
    # push tag
    - git push origin $MAIN_BRANCH "${new_tag}"
  rules:
    # if event = push && target = main
    - if: $CI_PIPELINE_SOURCE == 'push' &&
          $CI_COMMIT_BRANCH == $MAIN_BRANCH
  tags:
    - avataa-platform-docker
  interruptible: false


build_main:
  stage: build
  variables:
    DOCKER_HOST: ${DOCKER_HOST}
  image: ${DOCKER_DIND_IMAGE}:${DOCKER_DIND_VERSION}
  services:
    - ${DOCKER_DIND_IMAGE}:${DOCKER_DIND_VERSION}
  before_script:
    - mkdir -p ~/.ssh
    - echo "${SSH_PRIVATE_KEY}" > ~/.ssh/id_ed25519
    - chmod 600 ~/.ssh/id_ed25519
    # - echo "$SSH_KNOWN_HOSTS" > ~/.ssh/known_hosts
    # allow amd64
    # - |
    #   host_amd64=$(echo ${DOCKER_BUILDER_SSH_URL_AMD64} | cut -d'@' -f2-);
    #   ssh-keyscan -H ${host_amd64} >> ~/.ssh/known_hosts
    # allow arm64
    - |
      host_arm64=$(echo ${DOCKER_BUILDER_SSH_URL_ARM64} | cut -d'@' -f2-);
      ssh-keyscan -H ${host_arm64} >> ~/.ssh/known_hosts
    - new_version=$(cat ${BUILDS_CI_PATH}/${CI_PROJECT_NAME}_new_version)
  script:
    - docker login -u ${REGISTRY_PUSH_USER} -p ${REGISTRY_PUSH_PASSWORD} ${REGISTRY_URL}
    # create multiarch builder
    - docker buildx create --driver docker-container --platform ${BUILD_ARCH_AMD64} --name ${DOCKER_BUILDER_NAME} --use ${DOCKER_BUILDER_SSH_URL_AMD64}
    - docker buildx create --driver docker-container --platform ${BUILD_ARCH_ARM64} --name ${DOCKER_BUILDER_NAME} --append ${DOCKER_BUILDER_SSH_URL_ARM64}
    # check builder connections
    - docker buildx inspect --bootstrap
    # build latest tag + new version tag
    - docker buildx build
        --platform ${BUILD_ARCHS}
        --tag ${REGISTRY_URL}/${PROJECT_NAME}/${REGISTRY_MS_PATH}/${CI_PROJECT_NAME}:${LATEST_TAG}
        --tag ${REGISTRY_URL}/${PROJECT_NAME}/${REGISTRY_MS_PATH}/${CI_PROJECT_NAME}:${new_version}
        --tag ${REGISTRY_URL}/${PROJECT_NAME}/${REGISTRY_MS_PATH}/${GITHUB_PROJECT_NAME}:${LATEST_TAG}
        --tag ${REGISTRY_URL}/${PROJECT_NAME}/${REGISTRY_MS_PATH}/${GITHUB_PROJECT_NAME}:${new_version}
        --builder ${DOCKER_BUILDER_NAME}
        --provenance false
        --sbom false
        --push .
    # get image digest to sign image with cosign
    - IMAGE_DIGEST=$(docker buildx imagetools inspect --format "{{json .Manifest.Digest}}"
        ${REGISTRY_URL}/${PROJECT_NAME}/${REGISTRY_MS_PATH}/${CI_PROJECT_NAME}:${LATEST_TAG} | tr -d '"')
    - echo ${IMAGE_DIGEST} > ${BUILDS_CI_PATH}/${CI_PROJECT_NAME}_${IMAGE_DIGEST_FILENAME}
  rules:
    # if event = push && target = main
    - if: $CI_PIPELINE_SOURCE == 'push' &&
          $CI_COMMIT_BRANCH == $MAIN_BRANCH
  needs: ["generate_version"]
  tags:
    - avataa-platform-docker
  interruptible: false


sign_main:
  stage: build
  variables:
    COSIGN_PASSWORD: ${COSIGN_PASSWORD}
    COSIGN_PRIVATE_KEY: ${COSIGN_PRIVATE_KEY}
  image:
    name: ${COSIGN_IMAGE}:${COSIGN_VERSION}
    entrypoint: [""]
  script:
    - IMAGE_DIGEST=$(cat ${BUILDS_CI_PATH}/${CI_PROJECT_NAME}_${IMAGE_DIGEST_FILENAME})
    - cosign sign --yes --recursive --key env://COSIGN_PRIVATE_KEY
        --registry-username ${REGISTRY_PUSH_USER}
        --registry-password ${REGISTRY_PUSH_PASSWORD}
        ${REGISTRY_URL}/${PROJECT_NAME}/${REGISTRY_MS_PATH}/${CI_PROJECT_NAME}@${IMAGE_DIGEST}
  rules:
    # if event = push && target = main
    - if: $CI_PIPELINE_SOURCE == 'push' &&
          $CI_COMMIT_BRANCH == $MAIN_BRANCH
  needs: ["build_main"]
  tags:
    - avataa-platform-docker
  interruptible: false


deploy_main:
  stage: deploy
  script:
    - cd
    - docker login -u ${REGISTRY_PULL_USER} -p ${REGISTRY_PULL_PASSWORD} ${REGISTRY_URL}
    - docker pull ${REGISTRY_URL}/${PROJECT_NAME}/${REGISTRY_MS_PATH}/${CI_PROJECT_NAME}:${LATEST_TAG}
    - docker compose -f ${COMPOSE_PATH} up -d
  rules:
    # if event = push && target = main
    - if: $CI_PIPELINE_SOURCE == 'push' &&
          $CI_COMMIT_BRANCH == $MAIN_BRANCH
  tags:
    - avataa-platform-shell
  interruptible: false


cleanup:
  stage: cleanup
  script:
    - docker system prune --force
    # get digests without tag "develop" and remove them
    - source <(echo 'export PATH="$HOME/.local/bin:$PATH"');
    # clean images
    - |
      echo "Grab all images from registry for project ${PROJECT_NAME} and image ${CI_PROJECT_NAME}";
        images=$(curl -s -S -X 'GET' --max-time 7 \
        -u ${REGISTRY_USERNAME}:${REGISTRY_PASSWORD} \
        -H 'accept: application/json' \
        "${REGISTRY_PROTOCOL}://${REGISTRY_URL}/api/v2.0/projects/${PROJECT_NAME}/repositories/${REGISTRY_MS_PATH}%252F${CI_PROJECT_NAME}/artifacts?page=1&page_size=50&with_tag=true");
    - |
      # if no images
      if echo "${images}" | jq -e 'length == 0' >/dev/null ; then
          echo "No images for project ${PROJECT_NAME} and image ${CI_PROJECT_NAME}!";
          exit 0
      fi;
    - |
      # remove empty tags digests
      digests_to_remove=$(echo "${images}" | jq -cr '.[] | select( .tags == null ) | .digest');
      if [ -z "${digests_to_remove}" ] ; then
          echo "No images to remove!";
      else
          while IFS= read -r digest_to_remove; do
              echo -e "Remove image digest ${digest_to_remove}\n";
              curl -s -S -X 'DELETE' --max-time 7 \
                -u ${REGISTRY_USERNAME}:${REGISTRY_PASSWORD} \
                -H 'accept: application/json' \
                "${REGISTRY_PROTOCOL}://${REGISTRY_URL}/api/v2.0/projects/${PROJECT_NAME}/repositories/${REGISTRY_MS_PATH}%252F${CI_PROJECT_NAME}/artifacts/${digest_to_remove}"
          done < <(printf '%s\n' "${digests_to_remove}");
      fi;
    - |
      # remove all other than REGISTRY_VERSIONS_KEEP=3 last tags/versions, don't remove digest where more then REGISTRY_MAX_TAGS_IN_DIGEST=2
      images_to_filter_old_tags=$(echo "${images}" | jq -cr "
        [.[]
          | select(.tags != null)
          | select((.tags | map(.name) | index(\"$DEVELOP_TAG\") or index(\"$LATEST_TAG\") | not)
                  and ((.tags | length > $REGISTRY_MAX_TAGS_IN_DIGEST) | not))
        ]
      ");
      if echo "${images_to_filter_old_tags}" | jq -e 'length == 0' >/dev/null ; then
          echo "No images to remove!";
          exit 0
      else
        tags_old_versions_to_remove=$(echo "${images_to_filter_old_tags}" | jq -cr 'map(.tags) | flatten | unique | .[].name' \
          | grep -E '^[0-9]+\.[0-9]+\.[0-9]+$' \
          | sort -Vr \
          | tail -n +$((REGISTRY_VERSIONS_KEEP+1))
        );
        if [ -z "${tags_old_versions_to_remove}" ] ; then
            echo "No old versions to remove!";
            exit 0
        else
            while IFS= read -r tag_to_remove; do
                echo -e "Remove old image tag ${tag_to_remove}\n";
                if ! curl -s -S -X 'DELETE' --max-time 7 \
                  -u "${REGISTRY_USERNAME}:${REGISTRY_PASSWORD}" \
                  -H 'accept: application/json' \
                  "${REGISTRY_PROTOCOL}://${REGISTRY_URL}/api/v2.0/projects/${PROJECT_NAME}/repositories/${REGISTRY_MS_PATH}%252F${CI_PROJECT_NAME}/artifacts/${tag_to_remove}";
                then
                  echo "Failed to remove ${tag_to_remove}" >&2
                fi
            done < <(printf '%s\n' "${tags_old_versions_to_remove}");
        fi;
      fi;
    # clean alt images
    - |
      echo "Grab alternatively named images from registry for project ${PROJECT_NAME} and image ${GITHUB_PROJECT_NAME}";
        images=$(curl -s -S -X 'GET' --max-time 7 \
        -u ${REGISTRY_USERNAME}:${REGISTRY_PASSWORD} \
        -H 'accept: application/json' \
        "${REGISTRY_PROTOCOL}://${REGISTRY_URL}/api/v2.0/projects/${PROJECT_NAME}/repositories/${REGISTRY_MS_PATH}%252F${GITHUB_PROJECT_NAME}/artifacts?page=1&page_size=50&with_tag=true");
    - |
      # if no images
      if echo "${images}" | jq -e 'length == 0' >/dev/null ; then
          echo "No images for project ${PROJECT_NAME} and image ${GITHUB_PROJECT_NAME}!";
          exit 0
      fi;
    - |
      # remove empty tags digests
      digests_to_remove=$(echo "${images}" | jq -cr '.[] | select( .tags == null ) | .digest');
      if [ -z "${digests_to_remove}" ] ; then
          echo "No images to remove!";
      else
          while IFS= read -r digest_to_remove; do
              echo -e "Remove image digest ${digest_to_remove}\n";
              curl -s -S -X 'DELETE' --max-time 7 \
                -u ${REGISTRY_USERNAME}:${REGISTRY_PASSWORD} \
                -H 'accept: application/json' \
                "${REGISTRY_PROTOCOL}://${REGISTRY_URL}/api/v2.0/projects/${PROJECT_NAME}/repositories/${REGISTRY_MS_PATH}%252F${GITHUB_PROJECT_NAME}/artifacts/${digest_to_remove}"
          done < <(printf '%s\n' "${digests_to_remove}");
      fi;
    - |
      # remove all other than REGISTRY_VERSIONS_KEEP=3 last tags/versions, don't remove digest where more then REGISTRY_MAX_TAGS_IN_DIGEST=2
      images_to_filter_old_tags=$(echo "${images}" | jq -cr "
        [.[]
          | select(.tags != null)
          | select((.tags | map(.name) | index(\"$DEVELOP_TAG\") or index(\"$LATEST_TAG\") | not)
                  and ((.tags | length > $REGISTRY_MAX_TAGS_IN_DIGEST) | not))
        ]
      ");
      if echo "${images_to_filter_old_tags}" | jq -e 'length == 0' >/dev/null ; then
          echo "No images to remove!";
          exit 0
      else
        tags_old_versions_to_remove=$(echo "${images_to_filter_old_tags}" | jq -cr 'map(.tags) | flatten | unique | .[].name' \
          | grep -E '^[0-9]+\.[0-9]+\.[0-9]+$' \
          | sort -Vr \
          | tail -n +$((REGISTRY_VERSIONS_KEEP+1))
        );
        if [ -z "${tags_old_versions_to_remove}" ] ; then
            echo "No old versions to remove!";
            exit 0
        else
            while IFS= read -r tag_to_remove; do
                echo -e "Remove old image tag ${tag_to_remove}\n";
                if ! curl -s -S -X 'DELETE' --max-time 7 \
                  -u "${REGISTRY_USERNAME}:${REGISTRY_PASSWORD}" \
                  -H 'accept: application/json' \
                  "${REGISTRY_PROTOCOL}://${REGISTRY_URL}/api/v2.0/projects/${PROJECT_NAME}/repositories/${REGISTRY_MS_PATH}%252F${GITHUB_PROJECT_NAME}/artifacts/${tag_to_remove}";
                then
                  echo "Failed to remove ${tag_to_remove}" >&2
                fi
            done < <(printf '%s\n' "${tags_old_versions_to_remove}");
        fi;
      fi;
  rules:
    # if event = push && target = main
    - if: $CI_PIPELINE_SOURCE == 'push' &&
          $CI_COMMIT_BRANCH == $MAIN_BRANCH
  tags:
    - avataa-platform-shell
  interruptible: false